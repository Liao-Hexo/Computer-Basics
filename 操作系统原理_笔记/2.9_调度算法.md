饥饿：某进程/作业长期得不到服务

## 先来先服务FCFS

按照作业/进程到达的先后顺序进行服务，事实上就是等待时间越久的越优先得到服务

用于作业调度时，考虑的是哪个作业先到达后备队列（外存中）；用于进程调度时，考虑的是哪个进程先到达就绪队列（内存中）

非抢占式算法

优点：公平、算法实现简单

缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对长作业有利，对短作业不利

不会导致饥饿

## 最短作业优先SJF

追求最少的平均等待时间、最少的平均周转时间、最少的平均带权周转时间

最短的作业/进程优先得到服务（所谓最短是指要求服务时间最短），每次调度时选择当前已到达的且运行时间最短的作业/进程

既可用于作业调度，也可用于进程调度，用于进程调度时称为“短进程优先算法SPF”

SJF和SPF是非抢占式的算法，但是也有抢占式的版本：最短剩余时间优先算法SRTN

最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度

优点：“最短的”平均等待时间、平均周转时间

缺点：不公平，对短作业有利，对长作业不利。作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先

可能产生饥饿现象，如果源源不断的有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象，如果一直得不到服务，则称为饿死

平均等待时间、平均周转时间、平均带权周转时间由小到大：SRTN、SJF/SPF、FCFS

## 最高响应比优先HRRN

![](https://tva1.sinaimg.cn/large/008i3skNly1gr4ugd2evkj30hs0ck45s.jpg)

在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务

响应比 = （等待时间+要求服务时间）/ 要求服务时间【响应比 >= 1】

即可用于作业调度，也可用于进程调度

非抢占式的算法，因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比

综合考虑了等待时间和运行时间（要求服务时间），等待时间相同时，要求服务时间短的优先（SJF的优点），要求服务时间相同时，等待时间长的优先（FCFS的优点），对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题

⭐️以上三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕，因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法来使用，在现在也扮演着很重要的角色

## 时间片轮转RR

公平的、轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应

按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队

用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）

若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法，由时钟装置发出时钟中断来通知CPU时间片已到

如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间，因此时间片不能太大

另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少，可见时间片也不能太小

优点：公平、响应快、适用于分时操作系统

缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度

不会导致饥饿

## 优先级调度

随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序

每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程

既可用于作业调度，也可用于进程调度，甚至还会用于I/O调度中

抢占式、非抢占式都有，非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占

![](https://tva1.sinaimg.cn/large/008i3skNly1gr4w8jzpvcj30x20f2dw7.jpg)

优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活的调整对各种作业/进程的偏好程度

缺点：若源源不断的有高优先级进程到来，则可能导致饥饿

## 多级反馈队列

![](https://tva1.sinaimg.cn/large/008i3skNly1gr4wdcc4oxj30ee0cytey.jpg)

对其他调度算法的折中权衡

设置多级就绪队列，各级队列优先级从高到低，时间片从小到大；新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还不结束，则进程进入下一级队列队尾，如果此时已经是在最下级的队列，则重新放回该队列队尾；只有第k级队列为空时，才会为k+1级队头的进程分配时间片

用于进程调度

抢占式的算法，在k级队列的进程运行过程中，若更上级的队列（1～k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾

![](https://tva1.sinaimg.cn/large/008i3skNly1gr4wrcgzm1j30wg08g43w.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNly1gr4wswq556j30wg09cdll.jpg)

优点：

- 对各类型进程相对公平（FCFS的优点）
- 每个新到达的进程都可以很快就得到响应（RR的优点）
- 短进程只用较少的时间就可完成（SPF的优点）
- 不必实现估计进程的运行时间（避免用户作假）
- 可灵活的调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（可以将因I/O而阻塞的进程重新放回原队列，而不放回下一级队列，这样I/O型进程就可以保持较高优先级）

会导致饥饿，如果源源不断的有短进程到达的话，这种进程在第一级队列中就可以被处理完，已经被降级的进程就有可能导致饥饿

⭐️比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而以上这三种算法恰好也能较好的满足交互式系统的需求。因此这三种算法适合用于交互式系统（比如UNIX使用的就是多级反馈队列调度算法）